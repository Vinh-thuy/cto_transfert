import param
import panel as pn
import websockets
import asyncio
import json
import os
#import threading
import urllib.parse

# Configuration WebSocket
WEBSOCKET_CONFIG = {
    'host': os.getenv('WEBSOCKET_HOST', 'localhost'),  
    'port': int(os.getenv('WEBSOCKET_PORT', 8000)),       # Mise √† jour du port pour correspondre au nouveau serveur
    'path': '/v1/agents/langgraph/ws'  # Chemin complet pour l'agent LangGraph
}

model_id: str = 'gpt-4o-mini'
user_id: str = 'vinh'

# Statut de connexion personnalis√©
class ConnectionStatusIndicator(pn.widgets.Widget):
    """Indicateur de statut de connexion personnalis√©"""
    value = param.Boolean(default=False)
    
    def __init__(self, **params):
        super().__init__(**params)
        self._status_div = pn.pane.HTML(
            self._get_status_html(),
            height=30,
            width=150
        )
    
    def _get_status_html(self):
        """G√©n√©rer le HTML pour l'indicateur"""
        color = 'green' if self.value else 'red'
        status_text = 'Connect√©' if self.value else 'D√©connect√©'
        return f"""
        <div style="
            display: flex; 
            align-items: center; 
            padding: 5px; 
            border-radius: 5px; 
            background-color: {color}; 
            color: white;
            font-weight: bold;
        ">
            üîå {status_text}
        </div>
        """
    
    def _update_status(self, event=None):
        """Mettre √† jour l'affichage du statut"""
        self._status_div.object = self._get_status_html()
    
    def __panel__(self):
        """M√©thode requise pour les widgets Panel"""
        self.param.watch(self._update_status, 'value')
        return self._status_div
    
    def _get_model(self, doc, comm=None, **kwargs):
        """Impl√©mentation requise pour les widgets Panel"""
        from bokeh.models import Div
        
        color = 'green' if self.value else 'red'
        status_text = 'Connect√©' if self.value else 'D√©connect√©'
        
        div = Div(text=f"""
        <div style="
            display: flex; 
            align-items: center; 
            padding: 5px; 
            border-radius: 5px; 
            background-color: {color}; 
            color: white;
            font-weight: bold;
        ">
            üîå {status_text}
        </div>
        """, height=30, width=150)
        
        return div
    
    def _update_model(self, model, old, new):
        """Mettre √† jour le mod√®le Bokeh"""
        color = 'green' if new else 'red'
        status_text = 'Connect√©' if new else 'D√©connect√©'
        
        model.text = f"""
        <div style="
            display: flex; 
            align-items: center; 
            padding: 5px; 
            border-radius: 5px; 
            background-color: {color}; 
            color: white;
            font-weight: bold;
        ">
            üîå {status_text}
        </div>
        """

# Cr√©er l'indicateur de connexion
connection_status = ConnectionStatusIndicator(name='üîå Connexion')

def update_connection_status(is_connected: bool):
    """Met √† jour le statut de connexion"""
    connection_status.value = is_connected

class WebSocketClient:
    def __init__(self, uri, user_id, disable_lock=False):
        self.uri = uri
        self.user_id = user_id
        self.websocket = None
        self.connected = False
        self._connect_task = None
        self._session_id = None
        # Ajout du param√®tre disable_lock
        self._lock = None if disable_lock else asyncio.Lock()
        print(f"WebSocket URI initialis√©e : {self.uri}")
        # Si le verrou est d√©sactiv√©, afficher un avertissement
        if disable_lock:
            print("‚ö†Ô∏è ATTENTION : Verrou WebSocket d√©sactiv√© - √Ä UTILISER UNIQUEMENT POUR LES TESTS")

    async def connect(self):
        if self.connected:
            return True
            
        if self._connect_task and not self._connect_task.done():
            return await self._connect_task
        
        self._connect_task = asyncio.create_task(self._connect())
        return await self._connect_task

    async def _connect(self):
        try:
            print(f"Tentative de connexion √† : {self.uri}")
            
            # Ajouter du d√©bogage sans utiliser extra_headers qui n'est pas support√©
            print(f"Informations de d√©bogage - User-ID: {self.user_id}")
            
            self.websocket = await websockets.connect(
                self.uri,
                ping_interval=20,
                ping_timeout=20
            ) 
            self.connected = True
            update_connection_status(True)
            print("‚úÖ Connexion WebSocket √©tablie")
            
            # Attendre et traiter le message de bienvenue
            try:
                welcome_response = await asyncio.wait_for(self.websocket.recv(), timeout=10)
                print(f"üì• Message de bienvenue re√ßu : {welcome_response}")
                try:
                    welcome_data = json.loads(welcome_response)
                    if welcome_data.get('is_welcome', False):
                        print("üéâ Message de bienvenue trait√© avec succ√®s")
                except json.JSONDecodeError:
                    print("‚ùå Impossible de d√©coder le message de bienvenue")
            except asyncio.TimeoutError:
                print("‚è∞ Pas de message de bienvenue re√ßu dans le d√©lai imparti")
            except Exception as e:
                print(f"‚ùå Erreur lors de la r√©ception du message de bienvenue : {e}")
            
            # Lancer une t√¢che pour surveiller la connexion
            asyncio.create_task(self._monitor_connection())
            
            return True
        except Exception as e:
            print(f"‚ùå Erreur de connexion WebSocket : {type(e).__name__} - {str(e)}")
            self.connected = False
            update_connection_status(False)
            return False

    async def _monitor_connection(self):
        """Surveiller en continu l'√©tat de la connexion"""
        try:
            while self.connected:
                try:
                    # Envoyer un ping
                    await self.websocket.ping()
                    await asyncio.sleep(20)  # Attendre 20 secondes entre les pings
                except websockets.exceptions.ConnectionClosed:
                    print("‚ùå Connexion WebSocket ferm√©e")
                    self.connected = False
                    update_connection_status(False)
                    break
                except Exception as e:
                    print(f"‚ùå Erreur lors de la surveillance de la connexion : {type(e).__name__} - {str(e)}")
                    self.connected = False
                    update_connection_status(False)
                    break
        except Exception as e:
            print(f"‚ùå Erreur fatale dans _monitor_connection : {type(e).__name__} - {str(e)}")
            self.connected = False
            update_connection_status(False)

    async def send_message(self, message, info_only=False):
        # Gestion du verrou conditionnel
        if self._lock is not None:
            async with self._lock:
                return await self._send_message_impl(message, info_only)
        else:
            # Si le verrou est d√©sactiv√©, ex√©cution directe
            return await self._send_message_impl(message, info_only)

    async def _send_message_impl(self, message, info_only=False):
        if not self.connected:
            print("üîó Pas de connexion active, tentative de connexion...")
            success = await self.connect()
            if not success:
                print("‚ùå √âchec de la connexion WebSocket")
                return {'status': 'error', 'message': '√âchec de la connexion'}
        
        try:
            # Pr√©parer le payload pour un message informatif
            if info_only:
                message_payload = {
                    "type": "info",
                    "content": message,
                    "user_id": self.user_id
                }
            else:
                # Logique existante pour les messages standard
                if isinstance(message, dict):
                    message_payload = message.copy()
                    if 'user_id' not in message_payload:
                        message_payload["user_id"] = self.user_id
                    
                    # Adapter au nouveau format avec input_data si n√©cessaire
                    if 'input' in message_payload and 'input_data' not in message_payload:
                        message_payload["input_data"] = message_payload.pop("input")
                else:
                    # Format adapt√© pour LangGraph avec le nouveau champ input_data
                    message_payload = {
                        "input_data": message,
                        "user_id": self.user_id
                    }
            
            # Ajouter l'ID de session si disponible
            if self._session_id:
                message_payload["session_id"] = self._session_id
            
            # Convertir en JSON et envoyer
            json_payload = json.dumps(message_payload)
            print(f"üìû Envoi du payload au serveur: {json_payload}")
            
            await self.websocket.send(json_payload)
            
            if info_only:
                print("üí¨ Message informatif envoy√© avec succ√®s")
                return {'status': 'success'}
            
            # Pour les messages non informatifs, continuer avec la logique existante
            print("üí¨ Message envoy√© avec succ√®s, en attente de r√©ponse...")
            
            # Attendre la r√©ponse avec un timeout
            try:
                print("‚è≥ Attente de r√©ponse du serveur (timeout: 30s)...")
                response = await asyncio.wait_for(self.websocket.recv(), timeout=30)
                print(f"üì• R√©ponse brute re√ßue: {response[:100]}...")
                
                try:
                    response_data = json.loads(response)
                    print(f"üìö R√©ponse JSON pars√©e: {response_data}")
                except json.JSONDecodeError as json_error:
                    print(f"‚ùå Erreur de d√©codage JSON: {str(json_error)}")
                    print(f"R√©ponse brute compl√®te: {response}")
                    return {'status': 'error', 'message': 'R√©ponse non-JSON re√ßue'}
                
                # Ignorer les messages de ping
                if isinstance(response_data, dict) and response_data.get('type') == 'ping':
                    print("üèì Message ping re√ßu, en attente d'une r√©ponse valide")
                    response = await asyncio.wait_for(self.websocket.recv(), timeout=30)
                    response_data = json.loads(response)
                
                return response_data
            except asyncio.TimeoutError:
                return {'status': 'error', 'message': 'Timeout de la r√©ponse'}
            except Exception as e:
                return {'status': 'error', 'message': f'Erreur lors de la r√©ception : {str(e)}'}
        
        except Exception as e:
            print(f"‚ùå Erreur lors de l'envoi du message : {e}")
            return {'status': 'error', 'message': str(e)}

    async def close(self):
        if self.websocket:
            await self.websocket.close()
            self.connected = False
            update_connection_status(False)
            self._session_id = None

async def send_message_to_agent(message, context=None):
    """
    Envoi g√©n√©rique de message √† l'agent LangGraph
    
    Args:
        message (str): Message √† envoyer
        context (dict, optional): Contexte suppl√©mentaire
    
    Returns:
        dict: R√©ponse de l'agent avec le contenu d√©j√† pars√©
    """
    try:
        print(f"\nüì£ D√©but de send_message_to_agent avec message: {message}")
        # Format adapt√© pour LangGraph avec le nouveau format input_data
        payload = {
            "input_data": message  # Nouveau format avec input_data au lieu de input
        }
        
        # Ajouter le contexte si fourni
        if context:
            payload.update(context)
            
        print(f"üì¶ Payload pr√©par√©: {payload}")
        
        # D√©bug: Afficher le type de payload
        print("üîç Type de payload:", type(payload))
        
        # Envoi du message - Envoyer directement le payload, pas en tant que string JSON
        print("üí¨ Envoi du message au WebSocket...")
        
        # Tentative d'envoi avec plusieurs essais
        max_retries = 3
        for attempt in range(max_retries):
            try:
                print(f"üîÑ Tentative d'envoi {attempt + 1}/{max_retries}")
                response = await websocket_client.send_message(payload)
                print(f"üì• R√©ponse re√ßue: {response}")
                break
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur lors de l'envoi (tentative {attempt + 1}): {e}")
                if attempt == max_retries - 1:  # Derni√®re tentative
                    raise
                await asyncio.sleep(1)  # Attendre avant de r√©essayer
        
        # V√©rifier si la r√©ponse est valide
        if not response:
            print("‚ö†Ô∏è R√©ponse vide")
            return {'status': 'error', 'message': 'R√©ponse vide'}
        else:
            agent_name = response.get('agent_name', 'Inconnu')  # R√©cup√©rer agent_name de la r√©ponse
            print(f"Agent traitant la demande: {agent_name}")
            
            # Si la r√©ponse contient d√©j√† un statut d'erreur, le retourner directement
            if 'error' in response:
                print(f"‚ö†Ô∏è R√©ponse contient une erreur: {response['error']}")
                return {'status': 'error', 'message': response.get('error', 'Erreur inconnue')}
        
        if response:
            # Adaptation au format de r√©ponse LangGraph
            if 'result' in response:
                # Nouveau format de r√©ponse LangGraph (coh√©rent avec l'API REST)
                content = response.get('result', '')
                print(f"üëç Contenu extrait: {content[:100]}...")
                return {'status': 'success', 'data': {'response': content}}
            elif 'response' in response:
                # Ancien format pour compatibilit√©
                content = response.get('response', '')
                print(f"üëç Contenu extrait (ancien format): {content[:100]}...")
                return {'status': 'success', 'data': {'response': content}}
            else:
                # Autre format possible
                print(f"‚ö†Ô∏è Format de r√©ponse non standard: {response}")
                return {'status': 'success', 'data': {'response': str(response)}}
        
        print(f"‚úÖ R√©ponse de l'agent : {response}")
        return response
    
    except Exception as e:
        print(f"‚ùå Erreur lors de l'envoi du message : {e}")
        return {'status': 'error', 'message': f'Erreur lors de l\'envoi du message : {str(e)}'}

class ChatApp(param.Parameterized):
    def __init__(self, **params):
        super().__init__(**params)
        
        # Message de bienvenue initial
        welcome_message = """
        üëã Bienvenue dans votre Assistant Conversationnel Intelligent ! 

        Je suis votre compagnon num√©rique, pr√™t √† vous aider dans diverses t√¢ches :
        - üìö Raconter des histoires captivantes
        - ü§£ Partager des blagues amusantes
        - üîç R√©pondre √† vos questions
        - üí° Offrir des conseils et des informations

        N'h√©sitez pas √† me poser une question ou √† me demander quelque chose de fun !
        """
        
        # Initialisation des composants Panel
        self.chat_history = pn.Column(pn.pane.Markdown(welcome_message, sizing_mode='stretch_width'), scroll=True)

async def callback(contents: str, user: str, chat_instance: pn.chat.ChatInterface):
    global instance
    instance = chat_instance
    
    try:
        # Ne pas traiter les messages syst√®me ou assistant
        if user in ['Syst√®me', 'Assistant', 'ü§ñ Assistant']:
            return

        # Envoyer le message √† l'agent silencieusement
        print('callback send_message_to_agent ' , contents)
        
        # Message de d√©bogage temporaire pour l'utilisateur
        chat_instance.send("Traitement de votre demande...", user='Syst√®me')
        
        # Envoyer le message et attendre la r√©ponse
        print(f"üì£ Envoi du message √† l'agent: {contents}")
        response = await send_message_to_agent(contents)
        print(f"üíØ R√©ponse finale re√ßue: {response}")
        
        # Effacer tous les messages
        chat_instance.objects = []
        
        # Traiter la r√©ponse
        if response and response.get('status') == 'success':
            data = response.get('data', {})
            
            # Extraction du contenu principal
            content = data.get('response', '')
            
            # Envoi de la r√©ponse de l'agent
            if content:
                # Nettoyer le contenu des caract√®res d'√©chappement
                content = content.replace("\\'", "'").replace('\\"', '"')
                
                # Envoyer la r√©ponse textuelle
                print('callback send 2 chatbot as assistant message : ', content)
                chat_instance.send(content, user='ü§ñ Assistant')
            else:
                # Message d'erreur si pas de contenu
                chat_instance.send("Je n'ai pas pu g√©n√©rer de r√©ponse. Veuillez r√©essayer.", user='Syst√®me')
            

        else:
            print("Erreur de r√©ponse du serveur")
            
    except Exception as global_error:
        # Gestion des erreurs globales
        print(f"‚ùå Erreur globale : {global_error}")

# Variable globale pour stocker l'instance du chat
instance = None

# Initialisation du client WebSocket
websocket_client = WebSocketClient(
    uri=f"ws://{WEBSOCKET_CONFIG['host']}:{WEBSOCKET_CONFIG['port']}{WEBSOCKET_CONFIG['path']}?user_id={urllib.parse.quote(user_id)}",
    user_id=user_id
)

# Initialisation de l'interface de chat
chat_interface = pn.chat.ChatInterface(
    callback=callback,
    callback_user="üë§ Utilisateur",
    show_rerun=False,
    show_undo=False,
    show_clear=True,
    height=600,
    #sizing_mode='stretch_width',
    styles={
        '.chat-interface': {
            'width': '100%',
            'border': '1px solid #ddd',
            'border-radius': '5px',
            'background': '#fff',
            'display': 'flex',
            'flex-direction': 'column'
        },
        '.chat-interface-messages': {
            'flex-grow': '1',
            'height': 'calc(100% - 60px)',  # Hauteur totale moins la zone de saisie
            'overflow-y': 'scroll',
            'font-size': '12px',
            'padding': '10px'
        },
        '.chat-interface-input': {
            'height': '40px',
            'font-size': '12px',
            'margin': '10px',
            'border-radius': '1px'
        },
        '.chat-interface-message': {
            'padding': '5px 10px',
            'margin': '5px 0',
            'border-radius': '1px'
        }
    }
)



# Mise en page
header = pn.Row(
    pn.pane.Markdown('# üí¨ Chat Phidata'),
    pn.Spacer(width=20),
    connection_status,
    pn.Spacer(width=20),
    pn.Spacer(width=20),
    sizing_mode='stretch_width'
)

# Initialisation de Panel
pn.extension()



# Cr√©er un conteneur dynamique pour la zone sup√©rieure
dynamic_container = pn.Column(sizing_mode='stretch_width')


# Cr√©er un layout avec une seule colonne
main_layout = pn.Column(
    chat_interface,  # Colonne unique pour le chat
    sizing_mode='stretch_width',
    styles={'background': '#ffffff'}
)

# Template avec le layout en une colonne
template = pn.template.FastListTemplate(
    title='Chat LangGraph',  # Mise √† jour du titre
    header=header,
    main=[main_layout],  # Utiliser une liste avec le layout
    accent_base_color="#88d8b0",
    header_background="#88d8b0"
)

# Servir l'application
template.servable()
